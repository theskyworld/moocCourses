### 项目分析

​ ![image-20230826080141526](C:\Users\ycx\AppData\Roaming\Typora\typora-user-images\image-20230826080141526.png)

### 业务闭环

问卷创建者 → 新建问卷 → 编辑问卷 → 发布问卷 → 问卷H5页面
   👆                                           ⬇
分析结果   👈  后台统计并分析页面  👈 用户填写页面并提交

### 项目组件分析

![image-20230826080407619](C:\Users\ycx\AppData\Roaming\Typora\typora-user-images\image-20230826080407619.png)

### 项目页面

![image-20230828141801145](C:\Users\ycx\AppData\Roaming\Typora\typora-user-images\image-20230828141801145.png)

路由设计

- 首页 `'/'`
- 登录页 `'/login'`
- 注册页 `'/register'`
- 问卷管理
  - 我的问卷 `'/manage/list'`
  - 星标问卷 `'/manage/star'`
  - 回收站 `'/manage/trash'`
- 问卷详情
  - 编辑问卷 `/question/edit/:id`
  - 问卷统计 `/question/stat/:id`
- 404

### API 设计

设计时对应的前端需求

- 跟用户相关
  - 注册
  - 登录
  - 获取用户信息
- 跟问卷相关
  - 创建问卷
  - 获取单个问卷
  - 更新问卷
  - 删除问卷
  - 查询问卷列表
  - 复制问卷

#### 用户功能

##### 获取用户信息

`errno`为错误编号，其值为错误编码库中定义的值

- method `get`
- path `/api/user/info`
- response `{ errno: 0, data: {...} }` 或 `{ errno: 10001, msg: 'xxx' }`

##### 注册

- method `post`
- path `/api/user/register`
- request body `{ username, password, nickname }`
- response `{ errno: 0 }`

##### 登录

- method `post`
- path `/api/user/login`
- request body `{ username, password }`
- response `{ errno: 0, data: { token } }` —— **JWT** 使用 token

#### 问卷功能

##### 创建问卷

- method `post`
- path `/api/question`
- request body - 无 （点击一个按钮即可创建，title 自动生成）
- response `{ errno: 0, data: { id } }`

##### 获取单个问卷

- method `get`
- path `/api/question/:id`
- response `{ errno: 0, data: { id, title ... } }`

##### 获取问卷列表

- method `get`
- path `/api/question-list`
- response: `{ errno: 0, data: { list: [ ... ], total } }`

##### 更新问卷信息

- method `patch`
- path `/api/question/:id`
- request body `{ title, isStar ... }` （之前忘记了，现补上）
- response: `{ errno: 0 }`

PS：删除是`假删除`，实际是更新 `isDeleted` 属性

##### 批量彻底删除问卷

- method `delete`
- path `/api/question`
- request body `{ ids: [ ... ] }`
- response: `{ errno: 0 }`

##### 复制问卷

- method `post`
- path `/api/question/duplicate/:id`
- response: `{ errno: 0, data: { id } }`

#### 小结

- 使用 Restful API
- 用户验证使用 JWT （后面再讲）
- 统一返回格式 `{ errno, data, msg }`

### 解耦

#### 组件之间的解耦

- 搜索框与列表展示组件之间的解耦：搜索框的搜索结果不时来源于列表展示组件之中已有数据的过滤结果，而是通过输入搜索关键字之后，将关键字信息添加到url中，到后端请求到对应的搜索结果数据。当需要url中相关的数据时，可通过`useSearchParams`函数进行获取
- 分页与列表展示组件之间的解耦：类似于搜索框，将当前页数信息添加到url中，向后端请求到对应页的数据
- 同时星标问卷和回收站组件与列表组件之间的解耦也与上面类似，将`isStar`和`isDeleted`的信息传递给后端，进行数据的请求

#### 组件数据之间的解耦

- 使用状态提升，多个子组件的数据存储在共同的父组件中，通过props向子组件中传递数据
- 使用状态管理
  - 使用[Context](https://react.dev/learn/passing-data-deeply-with-context)
    - 类似于Vue中的`provide/inject`
    - 多用于例如主题切换、语言切换中
  - 使用[redux](https://redux.js.org/)
    - 对数据(state)进行统计的管理(dispatch action)

### 编辑界面分析

#### 界面的模块

- 顶部栏
- 左侧 - 组件库
- 左侧 - 图层
- 中间 - 画布
- 右侧 - 属性
- 右侧 - 页面设置

#### 功能列表

顶部栏

- 返回
- 显示标题，修改标题
- 工具栏
  - 删除
  - 隐藏
  - 锁定
  - 复制，粘贴
  - 上移，下移
  - 撤销，重做
- 保存，自动保存，ctrl + s 快捷键
- 发布

左侧 组件库

- 显示组件列表
  - （各个组件，看系统）
- 点击添加组件到画布

左侧 图层

- 显示图层列表
- 拖拽排序
- 单击，选中
- 双击，修改标题
- 隐藏
- 锁定

中间 画布

- 展示组件列表
- Y 滚动条
- 拖拽排序
- 单击，选中
- 快捷键
  - delete backspace
  - up
  - down
  - ctrl + c , v
  - ctrl + z , ctrl + shift + z
  - ctrl + s ，保存

右侧 属性

- 修改属性

右侧 页面设置

- 标题，描述
- JS CSS 代码
- tab 自动切换

#### 界面布局

- 上下布局
- 下面左中右局部
- 中部，上下左右居中布局
- 中部能沿y轴滚动

### 页面中拖拽排序功能的实现

使用以下第三方插件中的一种

- [React-dnd](https://react-dnd.github.io/react-dnd/about)
- [React-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd)
- [Sortable.js](https://sortablejs.github.io/Sortable/)
- [React-sortable-hoc](https://github.com/clauderic/react-sortable-hoc)
- [Dnd-Kit](https://dndkit.com/)

选择插件时，考虑以下内容

- Github star多，代码更新及时
- npm上下载量大，最近的发布时间较近
- 文档和demo通俗易懂
- 是否存在作者公布的例如暂停维护等信息

### 撤销重做的实现原理

#### 使用三个变量进行存储

- present : 存储页面中的当前数据值
- past : 一个数组栈结构，存储页面中的过去数据值
- future : 一个数组栈结构，存储页面中的将来数据值

#### 数据的更新流程

以一个输入框中输入值的撤销重做为例

- 撤销 : past出栈，future入栈，present重新被赋值
- 重做 : future出栈，past入栈，present重新被赋值
- 手动输入新值 : past入栈，future被清空内容

#### 使用工具

也可以使用例如[redux-undo](https://www.npmjs.com/package/redux-undo)工具，无需手动对数据进行维护，直接对其封装好的功能进行使用即可

### 统计页面分析

#### 界面的模块

- 顶部栏
- 左侧 组件列表
- 中间 答卷列表
- 右侧 图表统计

#### 功能列表

顶部栏

- 返回
- 显示标题
- 显示 url
- 复制 url
- 显示二维码
- 编辑问卷

左侧 组件列表

- 显示组件列表
- 点击选中组件

中间 答卷列表

- 显示答卷数量
- 显示答卷表格，分页
- 点击 th 选中组件

右侧 图表统计

- 根据选中的组件，显示图表统计

### 问卷统计数据结构分析

**一个问卷** 发布了，用户提交的**一份答卷**，数据结构如下：

```js
{
    questionId: '63a51dd42ef26594341e2aff',
    answerList: [
        { componentId: 'c1', value: undefined }, // 标题 info
        { componentId: 'c2', value: '张三' }, // input
        { componentId: 'c3', value: '13987650099' }, // input
        { componentId: 'c4', value: '1-3年' }, // 单选
        { componentId: 'c5', value: 'Vue2,Vue3' }, // 多选
        { componentId: 'c6', value: '大于20k' }, // 单选
        { componentId: 'c7', value: '备注xx' } // textarea
    ]
}
```

**一个问卷对应多个答卷**，所以一个问卷的所有答卷列表如下：

```js
[
    // 用户A
    {
        _id: 'xx',
        c2: '张三',
        c3: '13987650099',
        c4: '1-3年', // 单选
        c5: 'Vue2,Vue3', // 多选
        c6: '大于20k',
        c7: '备注xx'
    },
    // 用户B
    {
        _id: 'y',
        c2: '李四',
        c3: 'lisi@163.com',
        c4: '3-5年',
        c5: 'Vue2,React',
        c6: '10-20k',
        c7: '备注yy'
    },
    // 更多用户...
]
```

#### 完善 mock

根据上面的分析，可以设置 mock

```js
// url `/api/stat/:questionId`
// method `get`
{
    errno: 0,
    data: {
        total: 100, // 分页
        list: [ /* 上面的答卷列表 */ ]
    }
}
```

### 图表分析工具

- [React-chartjs-2](https://react-chartjs-2.js.org/)
- [recharts](https://recharts.org/)
- [echarts-for-react](https://www.npmjs.com/package/echarts-for-react)

### 性能优化

#### 优化`useState`

- 如果向`useState`中传入普通变量,则`useState`会在每次组件更新时执行
- 如果传入的为函数,则只会在组件初始渲染时执行一次
- 优化手段适合于数据结构复杂,计算成本较高的场景

```tsx
import { FC, useState } from "react";

// 用于生成初始的arr变量
function genArr() {
    console.log("genArr...");
    const arr : any[] = [];

    return arr;
}

const Demo: FC = () => {
    // useState中传入函数,该函数只会在组件初始渲染时执行一次
    // 不会跟随这以后每次组件更新时组件函数再执行而执行
    const [arr, setArr] = useState(genArr);

    // 更新arr
    // 该函数每执行一次,会导致状态arr的变化,导致组件的更新,组件函数的重新执行
    // 但是genArr函数只会在组件初始渲染时执行一次
    function addStrToArr() {
        setArr([...arr, "hello"]);
    }

    return (
        <>
            <p>length : {arr.length}</p>
            <div>
                <button onClick={addStrToArr}>add</button>
            </div>
        </>
    )
}

export default Demo;
```

#### 使用`useMemo`

- 由于组件在每次state更新时会进行更新,组件函数内的其它函数也会跟着更新
- 使用`useMomo`可以将数据进行缓存
- 适用于计算成本较高,依赖项不会经常变化的场景

#### 使用`useCallback`

类似于`useMemo`,用于缓存函数

#### 使用React.memo

- 当一个组件因为其state发生变化而进行更新时,不仅会导致其组件函数内的函数重新执行
- 还会导致其子组件随着进行更新,无论子组件的props是否变化
- 可以使用React.memo控制子组件的更新,当子组件的props发生变化时,子组件才进行更新
  
```tsx
import React, {FC} from "react";

interface ListProps {
  list : [];
}

const List : FC<ListProps> = (props) => {
  console.log("List组件更新...");

  return (
    <p>List组件</p>
  )
}

// 使用React.memo()
export defaut React.moemo(List);
```

#### 优化代码包体积

##### 使用[Analyzing the Bundle Size](https://create-react-app.dev/docs/analyzing-the-bundle-size/)工具分析代码体积大小

- 安装包 : `npm install --save source-map-explorer`
- 添加配置

```json
{
     "scripts": {
        "analyze": "source-map-explorer 'build/static/js/*.js'",
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
     }
}
```

- 执行命令

```shell
npm run build
npm run analyze
```

#### 使用路由懒加载

拆分首页中加载的内容,较小打包后main.js文件的体积,优化首页体积

拆分`EditIndex`和`StatIndex`组件

```tsx
// import EditIndex from "../pages/question/Edit";
// import StatIndex from "../pages/question/Stat";
import Register from "../pages/Register";

// 使用路由懒加载,将EditIndex和SateIndex组件单独加载,从打包后的main.js文件中拆分出来,
// 不在进行首页的时候就将这两个路由对应的组件进行加载, 需要时进行加载
// /*webpackChunkName : EditPage*/在打包后的文件名中添加EditPage的前缀,增加打包后文件名的可读性
const EditIndex = lazy(() => import(/*webpackChunkName : "EditPage"*/ "../pages/question/Edit"));
const StatIndex = lazy(() => import(/*webpackChunkName : "StatPage"*/"../pages/question/Stat"));
```
